The Fountain Protocol on Hedera

The Fountain Protocol will use Hedera Token Service (HTS) and the Hedera Consensus Service (HCS) to manage its tokens and state. Three native HTS tokens are defined: $DRIP (a non-transferable fungible token), $WISH (a utility fungible token with daily claim and burn mechanics), and $DROP (a non-fungible recognition token). All operations on these tokens use HTS and on-ledger features; e.g. $WISH will conform to the ERC-20 interface on Hedera’s EVM ￼. A daily off-chain process will snapshot state at 00:00 UTC each day, compute protocol metrics (denoted Nₜ, Dₜ, gₜ, C, Mₜ, Bₜ, Eₜ), and publish them to an HCS topic for transparency. This design leverages key HTS features (freeze, supply, wipe, etc.) and the Mirror Node REST API for querying balances, and it uses keeper scripts or scheduled jobs to automate snapshots and claims.

HTS Token Designs
	•	$DRIP Token: A fungible token that is non-transferable by design. We set defaultFreeze = true and assign a freezeKey to a protocol-controlled account ￼. Because of default freeze, any account is frozen upon association and cannot receive $DRIP until the protocol (using the freeze key) explicitly unfollows them. In practice, the backend “smart controller” will unfreeze a recipient account, transfer $DRIP from the treasury to them, and then re-freeze the account. Once frozen again, that account’s $DRIP balance cannot be moved by the user (only the freeze key holder could unfreeze and re-transfer, which is not permitted in normal operation). This effectively enforces non-transferability. The token is created as FUNGIBLE_COMMON (likely with 0 decimals if $DRIP is an integer count), with an adminKey (for future upgrades), a supplyKey (to mint new $DRIP as needed), and the freezeKey as above. No KYC is needed if the protocol handles identity off-chain. The treasury account holds new mintings until distributed.
	•	$WISH Token: A fungible “utility” token with ERC-20 compatibility. Create it via HTS with an adminKey and a supplyKey for controlled minting, and optionally a wipeKey to burn from any account. It should have a standard decimal precision (e.g. 18 decimals) and no special freeze/KYC (so defaultFreeze = false) so that it behaves like a normal ERC-20. After creation, its token address (the Hedera token ID in Solidity format) can be used in EVM calls – for example, calling transfer(address,uint256) on its contract address will trigger an HTS transfer under the hood ￼. This ensures compatibility with Hedera EVM DEXes like SaucerSwap. Minting of $WISH is controlled by off-chain logic: each day the protocol will mint a calculated amount to a treasury or distribution account, and allow users to claim up to their entitlement (subject to the lifetime cap of 1,000 per $DRIP owned). For redemption/burning, the protocol designates a public “sink” account. Users send $WISH to this sink address to redeem value; the backend then uses the wipeKey or supplyKey to burn those tokens from circulation, maintaining a fixed peg. (Alternatively, tokens sent to the sink could simply be left irrecoverable. Using a wipe/burn ensures the reported total supply reflects burns.)
	•	$DROP Token: A non-fungible recognition token (NFT). Define it as NON_FUNGIBLE_UNIQUE in HTS, so each issued $DROP has a unique serial number. It serves as a one-time badge per donor. Use an adminKey and supplyKey for minting. No freeze/KYC is needed unless transfers are to be restricted (likely transfers are allowed, but the protocol’s off-chain logic will only mint at most one per account). Whenever the backend detects a donation above the threshold (via monitoring transactions or external data), it mints one $DROP NFT to that donor’s Hedera account (if they don’t already have one). The NFT’s metadata can encode donation info or simply mark the achievement. Because it’s unique per wallet, the backend should check via the Mirror Node (e.g. querying /api/v1/accounts/{accountId}/nfts or /tokens/{dropId}/balances) before minting to enforce the “once per wallet” rule.

Key and Permission Configuration

Each token’s HTS settings use precise keys and flags:
	•	$DRIP: Set freezeDefault = true ￼ so all accounts start frozen. Assign a freezeKey (held by the protocol) that can unfreeze accounts for distribution. Optionally also assign an adminKey for metadata updates and a supplyKey for minting new $DRIP. No wipeKey is needed (and burning should likely only happen via transfer to treasury and burn if ever). This ensures $DRIP is essentially non-transferable (frozen by default) and only the controller can distribute it.
	•	$WISH: Standard fungible token. Assign adminKey and supplyKey. Optionally assign a wipeKey if burning from any account is desired (e.g. wipe sink balance). Set freezeDefault = false, no freeze or KYC keys. Choose a reasonable maxSupply or leave infinite (mint controlled by logic). Decimals (e.g. 18) ensure ERC-20 style. This config allows ERC-20-like operations via HTS precompiles ￼.
	•	$DROP: Non-fungible (NFT) with supplyKey to mint each time. Use admin and supply keys; no freeze/KYC. Set supplyType=INFINITE or a large finite limit. Each mint creates a new serial into treasury or directly to account. Transfer restrictions (freeze) are not needed unless you want to prevent NFT sales; by default holders can transfer or sell their $DROP if they choose, which might be acceptable for this recognition token.

Daily State Snapshot (HCS)

Each day at 00:00 UTC, the protocol runs a snapshot cycle. The off-chain server (keeper) does the following:
	1.	Snapshot $DRIP Balances: Query the Mirror Node’s REST API for the distribution of $DRIP. For example, use the endpoint /api/v1/tokens/{tokenId}/balances?timestamp=... set to 00:00:00 UTC ￼. This returns all accounts holding $DRIP and their balances as of the given timestamp. Alternatively, use the Token Balance Snapshot tool or /api/v1/accounts/{accountId}/tokens for each account, but the balances endpoint is more direct. Let Nₜ = total number of DRIP tokens or number of holders, depending on protocol needs.
	2.	Collect Daily Metrics: Gather donation and network data. For example, set Dₜ to be the total donation amount (if donations are on-chain, query HBAR transfer totals to a donation account via Mirror Node; if off-chain, import from external records). Compute any growth factors gₜ (e.g. new donors vs total, or donation rate). These variables feed the entitlement formula.
	3.	Compute Entitlements: Using protocol-defined formulas (e.g. target distribution per $DRIP, caps, etc.), calculate how many $WISH tokens can be claimed by $DRIP holders today, and individual entitlements Eₜ^(i) per account. Also compute Mₜ = total new $WISH to mint for today and Bₜ = total anticipated burns. The lifetime cap (1,000 per DRIP) means each account’s claim must not exceed 1000 × (DRIP balance), so track cumulative claims in a database or ledger.
	4.	Publish to HCS: Package the snapshot data into a message. For example, form a JSON with fields N_t, D_t, g_t, C, M_t, B_t, E_t (where E_t could be total or include per-token share). Submit it via a ConsensusSubmitMessageTransaction to a pre-created HCS topic (the “snapshot topic”). HCS topics ensure an immutable, time-ordered log. The developer first creates the topic with ConsensusTopicCreateTransaction ￼, obtaining a topicId. (Set a Topic adminKey so only the protocol can post; no submitKey needed if public submission is allowed or vice versa.) The transaction receipt gives the topicId; thereafter the keeper will use ConsensusSubmitMessage daily. All topic messages have unique sequence numbers and timestamps ￼.
	5.	Make HCS Messages Accessible: Mirror Nodes index topic messages; downstream services can retrieve them via /api/v1/topics/{topicId}/messages ￼. This provides an audit trail of all state snapshots (including the variables above) for transparency and use by clients. By publishing these to HCS, any independent observer can verify the protocol’s daily parameters.

Claim and Redemption Logic

The protocol enforces daily $WISH claims and redemption with off-chain checks and on-chain token operations:
	•	Daily Claim: After the snapshot is posted, DRIP holders can claim their allotted $WISH. In practice, the backend (or smart contract controller) will distribute $WISH from the treasury to each eligible account. One approach is to have users trigger a “claim” (e.g. by sending a minimal transaction or calling a claim endpoint), and the server verifies against the snapshot and lifetime caps, then issues an HTS CryptoTransfer of the appropriate $WISH amount. Because HTS does not natively enforce caps or time limits, the enforcement is done by the off-chain service. The service tracks each account’s total $WISH received vs. 1000 × DRIP balance and rejects further claims beyond the cap. This is akin to how Hedera staking rewards are collected by the user initiating a transaction (see e.g. Hashpack’s staking) – here the “claim” by the user triggers the actual token grant.
	•	Redemption (Burn): To redeem value (the “fixed peg”), users send their $WISH to the designated burn/sink address. The protocol monitors this sink’s balance (via Mirror Node or direct queries). It then uses HTS to burn those tokens: since $WISH has a supply key (or wipe key), the backend executes a TokenBurnTransaction (or TokenWipeTransaction on the sink) to remove that amount from supply. For example, if a user sends 50 $WISH to the sink, the service submits a burn of 50 from the treasury (or wipe 50 from the sink’s account). This both reduces circulating supply and finalizes redemption. All burn operations are also recorded in daily metrics (Bₜ). Importantly, burning via HTS adjusts totalSupply, so EVM/ERC-20 view of total supply remains correct.
	•	Lifetime Cap: The rule “max 1,000 WISH per DRIP token” is enforced by the off-chain controller. Every claim or burn event is logged and checked against each account’s historical total. The snapshot HCS messages can help verify published entitlements against actual distribution. Because HTS cannot embed this logic, the keeper service (or a smart contract if one were used) is responsible. If desired, one could also require users to “lock” their $DRIP balance when claiming or use a vesting mechanism via a contract, but such complexity is not necessary if off-chain tracking is reliable.

Mirror Node and Off-Chain Infrastructure

Building on Hedera’s mirror node and consensus services, the following components are required:
	•	Hedera Nodes: Use Hedera’s public testnet (and eventually mainnet) for all transactions. Configure operator accounts via the Hedera Portal or CLI. No private nodes are needed unless customizing. Ensure accounts have auto-renew enabled or monitor expiry if tokens/Topics need renewal.
	•	Mirror Node API: The protocol’s backend uses Hedera Mirror Node REST APIs to query state. For example, /api/v1/tokens/{DRIP_id}/balances (with an optional timestamp query) returns the distribution of $DRIP across accounts ￼. Similarly, /api/v1/accounts/{account}/transactions or token transfers endpoints can track donation activity or $WISH transfers. HCS messages are read via /api/v1/topics/{topicId}/messages ￼, which returns all submitted snapshot messages (with their consensus timestamp and content). This lets third-party tools display the daily state log.
	•	Off-Chain Server (“Keeper”): A scheduled service (e.g. a cron job, Kubernetes CronJob, AWS Lambda, etc.) runs at a fixed time each UTC day. It performs the snapshot steps above: fetch balances and donations, compute entitlements, post to HCS, mint $WISH, and enable claims. Another component watches for $WISH burn signals (tokens arriving in the sink) and triggers the HTS burn. All token operations are performed via Hedera SDK or REST calls using the protocol’s private keys (admin/supply keys).
	•	Database/State Storage: To enforce caps and track history, the backend maintains a simple database of accounts’ total $WISH claimed. It also logs each HCS message sent (to cross-check) and donation events. Optionally, a graph database could index holders and transaction history for advanced analytics, but at minimum, a relational store or even on-file ledger of cumulative claims suffices.
	•	Wallet/User Interface: Front-end or wallet integration (e.g. HashPack) will allow users to connect their Hedera account, view their $DRIP balance (via Mirror Node query), and claim $WISH. It can fetch the latest HCS snapshot to show entitled amounts. For burning, the UI instructs users to send $WISH to the sink account or to call a “redeem” function which does so.
	•	Automation & Reliability: The keeper must handle network time drift (use an NTP service for UTC alignment). If a run fails, retries or monitoring alerts should catch missed snapshots. All transactions (topic posts, token mints/burns) should wait for consensus receipts to confirm success.

Testnet Deployment

Testing and deployment use Hedera’s testnet endpoints. For example, configure the Mirror Node base URL as https://testnet.mirrornode.hedera.com/ ￼ and the Hedera SDK network to testnet. Create developer accounts via the Hedera Portal; these will serve as treasury, admin, etc. Deploy the HCS topic on testnet with ConsensusTopicCreateTransaction and note the topic ID. Create the HTS tokens on testnet by submitting TokenCreateTransaction (with the chosen keys and parameters). Funds the treasury accounts with testnet HBAR for fees. Use testnet for full end-to-end: mint DRIP to test accounts, simulate donation events, run snapshots, and claim WISH. Verify Mirror Node queries (e.g. try fetching /api/v1/accounts/{acct}/tokens). Document the testnet addresses of all tokens and topics; ensure front-end points to testnet network.